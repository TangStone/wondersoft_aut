{"name": "配置数据源", "status": "failed", "statusDetails": {"message": "AssertionError", "trace": "self = <pages.common_page.CommonPage object at 0x00000179E2943640>\nmessage = '参数配置正确', locator = '[role=alert]'\n\n    @allure.step(\"断言 --> 显示提示信息：{message}\")\n    def assert_prompt_information(self, message, locator=\"[role=alert]\"):\n        \"\"\"\n        断言：等待提示信息出现，并验证提示信息\n        :param locator:\n        :param message:\n        :return:\n        \"\"\"\n        logger.info(f\"____元素 - {locator} 包含 - {message}\")\n        try:\n            self.page.locator(locator).wait_for()\n>           expect(self.page.locator(locator)).to_have_text(message)\n\npages\\common_page.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <playwright._impl._assertions.LocatorAssertions object at 0x00000179E24E1940>\nexpected = '参数配置正确'\n\n    def to_have_text(\n        self,\n        expected: typing.Union[\n            typing.Sequence[str],\n            typing.Sequence[typing.Pattern[str]],\n            typing.Sequence[typing.Union[typing.Pattern[str], str]],\n            typing.Pattern[str],\n            str,\n        ],\n        *,\n        use_inner_text: typing.Optional[bool] = None,\n        timeout: typing.Optional[float] = None,\n        ignore_case: typing.Optional[bool] = None\n    ) -> None:\n        \"\"\"LocatorAssertions.to_have_text\n    \n        Ensures the `Locator` points to an element with the given text. All nested elements will be considered when\n        computing the text content of the element. You can use regular expressions for the value as well.\n    \n        **Details**\n    \n        When `expected` parameter is a string, Playwright will normalize whitespaces and line breaks both in the actual\n        text and in the expected string before matching. When regular expression is used, the actual text is matched as is.\n    \n        **Usage**\n    \n        ```py\n        import re\n        from playwright.sync_api import expect\n    \n        locator = page.locator(\\\".title\\\")\n        expect(locator).to_have_text(re.compile(r\\\"Welcome, Test User\\\"))\n        expect(locator).to_have_text(re.compile(r\\\"Welcome, .*\\\"))\n        ```\n    \n        If you pass an array as an expected value, the expectations are:\n        1. Locator resolves to a list of elements.\n        1. The number of elements equals the number of expected values in the array.\n        1. Elements from the list have text matching expected array values, one by one, in order.\n    \n        For example, consider the following list:\n    \n        ```html\n        <ul>\n          <li>Text 1</li>\n          <li>Text 2</li>\n          <li>Text 3</li>\n        </ul>\n        ```\n    \n        Let's see how we can use the assertion:\n    \n        ```py\n        from playwright.sync_api import expect\n    \n        # ✓ Has the right items in the right order\n        expect(page.locator(\\\"ul > li\\\")).to_have_text([\\\"Text 1\\\", \\\"Text 2\\\", \\\"Text 3\\\"])\n    \n        # ✖ Wrong order\n        expect(page.locator(\\\"ul > li\\\")).to_have_text([\\\"Text 3\\\", \\\"Text 2\\\", \\\"Text 1\\\"])\n    \n        # ✖ Last item does not match\n        expect(page.locator(\\\"ul > li\\\")).to_have_text([\\\"Text 1\\\", \\\"Text 2\\\", \\\"Text\\\"])\n    \n        # ✖ Locator points to the outer list element, not to the list items\n        expect(page.locator(\\\"ul\\\")).to_have_text([\\\"Text 1\\\", \\\"Text 2\\\", \\\"Text 3\\\"])\n        ```\n    \n        Parameters\n        ----------\n        expected : Union[Pattern[str], Sequence[Pattern[str]], Sequence[Union[Pattern[str], str]], Sequence[str], str]\n            Expected string or RegExp or a list of those.\n        use_inner_text : Union[bool, None]\n            Whether to use `element.innerText` instead of `element.textContent` when retrieving DOM node text.\n        timeout : Union[float, None]\n            Time to retry the assertion for in milliseconds. Defaults to `5000`.\n        ignore_case : Union[bool, None]\n            Whether to perform case-insensitive match. `ignoreCase` option takes precedence over the corresponding regular\n            expression flag if specified.\n        \"\"\"\n        __tracebackhide__ = True\n    \n        return mapping.from_maybe_impl(\n>           self._sync(\n                self._impl_obj.to_have_text(\n                    expected=mapping.to_impl(expected),\n                    useInnerText=use_inner_text,\n                    timeout=timeout,\n                    ignoreCase=ignore_case,\n                )\n            )\n        )\n\n.venv\\lib\\site-packages\\playwright\\sync_api\\_generated.py:18929: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <playwright._impl._assertions.LocatorAssertions object at 0x00000179E24E1940>\ncoro = <coroutine object LocatorAssertions.to_have_text at 0x00000179E29504C0>\n\n    def _sync(\n        self,\n        coro: Union[Coroutine[Any, Any, Any], Generator[Any, Any, Any]],\n    ) -> Any:\n        __tracebackhide__ = True\n        if self._loop.is_closed():\n            coro.close()\n            raise Error(\"Event loop is closed! Is Playwright already stopped?\")\n    \n        g_self = greenlet.getcurrent()\n        task: asyncio.tasks.Task[Any] = self._loop.create_task(coro)\n        setattr(task, \"__pw_stack__\", inspect.stack())\n        setattr(task, \"__pw_stack_trace__\", traceback.extract_stack())\n    \n        task.add_done_callback(lambda _: g_self.switch())\n        while not task.done():\n            self._dispatcher_fiber.switch()\n        asyncio._set_running_loop(self._loop)\n>       return task.result()\n\n.venv\\lib\\site-packages\\playwright\\_impl\\_sync_base.py:113: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <playwright._impl._assertions.LocatorAssertions object at 0x00000179E24E1940>\nexpected = '参数配置正确', useInnerText = None, timeout = None, ignoreCase = None\n\n    async def to_have_text(\n        self,\n        expected: Union[\n            Sequence[str],\n            Sequence[Pattern[str]],\n            Sequence[Union[Pattern[str], str]],\n            Pattern[str],\n            str,\n        ],\n        useInnerText: bool = None,\n        timeout: float = None,\n        ignoreCase: bool = None,\n    ) -> None:\n        __tracebackhide__ = True\n        if isinstance(expected, collections.abc.Sequence) and not isinstance(\n            expected, str\n        ):\n            expected_text = to_expected_text_values(\n                expected,\n                normalize_white_space=True,\n                ignoreCase=ignoreCase,\n            )\n            await self._expect_impl(\n                \"to.have.text.array\",\n                FrameExpectOptions(\n                    expectedText=expected_text,\n                    useInnerText=useInnerText,\n                    timeout=timeout,\n                ),\n                expected,\n                \"Locator expected to have text\",\n            )\n        else:\n            expected_text = to_expected_text_values(\n                [expected], normalize_white_space=True, ignoreCase=ignoreCase\n            )\n>           await self._expect_impl(\n                \"to.have.text\",\n                FrameExpectOptions(\n                    expectedText=expected_text,\n                    useInnerText=useInnerText,\n                    timeout=timeout,\n                ),\n                expected,\n                \"Locator expected to have text\",\n            )\n\n.venv\\lib\\site-packages\\playwright\\_impl\\_assertions.py:471: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <playwright._impl._assertions.LocatorAssertions object at 0x00000179E24E1940>\nexpression = 'to.have.text'\nexpect_options = {'expectedText': [{'matchSubstring': False, 'normalizeWhiteSpace': True, 'string': '参数配置正确'}], 'isNot': False, 'timeout': 5000}\nexpected = '参数配置正确', message = 'Locator expected to have text'\n\n    async def _expect_impl(\n        self,\n        expression: str,\n        expect_options: FrameExpectOptions,\n        expected: Any,\n        message: str,\n    ) -> None:\n        __tracebackhide__ = True\n        expect_options[\"isNot\"] = self._is_not\n        if expect_options.get(\"timeout\") is None:\n            expect_options[\"timeout\"] = self._timeout or 5_000\n        if expect_options[\"isNot\"]:\n            message = message.replace(\"expected to\", \"expected not to\")\n        if \"useInnerText\" in expect_options and expect_options[\"useInnerText\"] is None:\n            del expect_options[\"useInnerText\"]\n        result = await self._actual_locator._expect(expression, expect_options)\n        if result[\"matches\"] == self._is_not:\n            actual = result.get(\"received\")\n            if self._custom_message:\n                out_message = self._custom_message\n                if expected is not None:\n                    out_message += f\"\\nExpected value: '{expected or '<None>'}'\"\n            else:\n                out_message = (\n                    f\"{message} '{expected}'\" if expected is not None else f\"{message}\"\n                )\n>           raise AssertionError(\n                f\"{out_message}\\nActual value: {actual} {format_call_log(result.get('log'))}\"\n            )\nE           AssertionError: Locator expected to have text '参数配置正确'\nE           Actual value: 提示没有连接权限,账号或密码不正确！ \nE           Call log:\nE           LocatorAssertions.to_have_text with timeout 5000ms\nE             - waiting for locator(\"[role=alert]\")\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\nE             -   locator resolved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\nE             -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\n\n.venv\\lib\\site-packages\\playwright\\_impl\\_assertions.py:70: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nfixturefunc = <function step_assert_message at 0x00000179E228E5E0>\nrequest = <FixtureRequest for <Function test_配置数据源>>\nkwargs = {'message': '参数配置正确', 'page': <Page url='https://192.168.148.174:31000/sub-app-unity/userSync'>}\n\n    def call_fixture_func(\n        fixturefunc: \"_FixtureFunc[FixtureValue]\", request: FixtureRequest, kwargs\n    ) -> FixtureValue:\n        if is_generator(fixturefunc):\n            fixturefunc = cast(\n                Callable[..., Generator[FixtureValue, None, None]], fixturefunc\n            )\n            generator = fixturefunc(**kwargs)\n            try:\n                fixture_result = next(generator)\n            except StopIteration:\n                raise ValueError(f\"{request.fixturename} did not yield a value\") from None\n            finalizer = functools.partial(_teardown_yield_fixture, fixturefunc, generator)\n            request.addfinalizer(finalizer)\n        else:\n            fixturefunc = cast(Callable[..., FixtureValue], fixturefunc)\n>           fixture_result = fixturefunc(**kwargs)\n\n.venv\\lib\\site-packages\\_pytest\\fixtures.py:908: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntest_cases\\conftest.py:68: in step_assert_message\n    CommonPage(page).assert_prompt_information(message)\npages\\common_page.py:216: in assert_prompt_information\n    ExceptionHandle().handle_exception(e, \"assert\")\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <utils.base_utils.exception_handle.ExceptionHandle object at 0x00000179E2937940>\nexception = AssertionError('Locator expected to have text \\'参数配置正确\\'\\nActual value: 提示没有连接权限,账号或密码不正确！ \\nCall log:\\nLocatorAsserti...lved to <div role=\"alert\" class=\"el-notification topZIndexTip…>…</div>\\n  -   unexpected value \"提示没有连接权限,账号或密码不正确！\"\\n')\nex_type = 'assert'\n\n        def handle_exception(self, exception, ex_type=\"\"):\n            \"\"\"\n            处理异常信息\n            :param ex_type: 异常类型 assert: 在校验时发生的异常\n            :param exception: 异常信息\n            :return:\n            \"\"\"\n            # 处理异常\n            exception_type = type(exception).__name__\n            if exception_type == \"TimeoutError\":\n                err_msg = f\"\"\"元素定位超时\"\"\"\n            elif exception_type == \"AssertionError\":\n                err_msg = f\"\"\"校验失败\"\"\"\n            else:\n                if re.match(\"Error: strict mode violation:.*resolved to.*elements:\", str(exception)):\n                    err_msg = f\"\"\"定位到多个元素\"\"\"\n                else:\n                    err_msg = f\"\"\"未知异常\"\"\"\n            trac = traceback.format_exc()\n            # 处理allure报告\n            attach_body = f\"\"\"\n    {err_msg}：{exception}\n    详细报错信息如下：\n    {trac}\n    \"\"\"\n            logger.error(trac)\n            # 添加异常信息\n            if ex_type == 'assert':    #校验时出现的异常\n                allure.attach(name=\"测试用例校验失败：\", body=attach_body)\n>               assert False\nE               AssertionError\n\nutils\\base_utils\\exception_handle.py:58: AssertionError"}, "description": "E:\\Wondersoft_AutoTest\\test_cases\\features\\bms\\user_sync.feature: 配置数据源", "steps": [{"name": "打开网站：'https://192.168.148.174:31000/'", "status": "passed", "parameters": [{"name": "url", "value": "'https://192.168.148.174:31000/'"}], "start": 1719192992178, "stop": 1719192992417}, {"name": "判断是否需要重新登录", "status": "passed", "parameters": [{"name": "full_url", "value": "'https://192.168.148.174:31000/portal-login'"}, {"name": "username", "value": "'admin'"}, {"name": "password", "value": "'Ws-123456'"}], "start": 1719192992419, "stop": 1719192994433}, {"name": "点击一级菜单：'用户管理'", "status": "passed", "parameters": [{"name": "men", "value": "'用户管理'"}], "start": 1719192994434, "stop": 1719192994545}, {"name": "点击二级菜单：'用户同步管理'下的三级菜单：'用户同步'", "status": "passed", "parameters": [{"name": "sec_men", "value": "'用户同步管理'"}, {"name": "thi_men", "value": "'用户同步'"}], "start": 1719192994546, "stop": 1719192996569}, {"name": "切换标签页：'数据源配置'", "status": "passed", "parameters": [{"name": "tab", "value": "'数据源配置'"}], "start": 1719192996570, "stop": 1719192997964}, {"name": "点击按钮：'新增'", "status": "passed", "parameters": [{"name": "button", "value": "'新增'"}, {"name": "page_name", "value": "None"}], "start": 1719192997965, "stop": 1719192998082}, {"name": "选择数据源类型：'LDAP域'", "status": "passed", "parameters": [{"name": "data_source_type", "value": "'LDAP域'"}], "start": 1719192998083, "stop": 1719192999042}, {"name": "AD域参数配置: {'数据源名称': '70.235', '域地址': '192.168.70.235', '域端口': '389', '域管理员账号': 'xiantest\\\\administrator', '域管理员密码': 'Ws-123456r', '根域名': 'DC=xiantest,DC=com', '组织机构名称': 'ou=北京明朝万达', '启用加密': False, '用户过滤条件': '', '组织过滤条件': '', '是否增量同步': False}", "status": "passed", "parameters": [{"name": "domain_config", "value": "{'数据源名称': '70.235', '域地址': '192.168.70.235', '域端口': '389', '域管理员账号': 'xiantest\\\\administrator', '域管理员密码': 'Ws-123456r', '根域名': 'DC=xiantest,DC=com', '组织机构名称': 'ou=北京明朝万达', '启用加密': False, '用户过滤条件': '', '组织过滤条件': '', '是否增量同步': False}"}], "start": 1719192999043, "stop": 1719192999260}, {"name": "点击按钮：'测试'", "status": "passed", "parameters": [{"name": "button", "value": "'测试'"}, {"name": "page_name", "value": "None"}], "start": 1719192999261, "stop": 1719192999321}, {"name": "断言 --> 显示提示信息：'参数配置正确'", "status": "failed", "statusDetails": {"message": "AssertionError\n", "trace": "  File \"E:\\Wondersoft_AutoTest\\.venv\\lib\\site-packages\\allure_commons\\_allure.py\", line 192, in impl\n    return func(*a, **kw)\n  File \"E:\\Wondersoft_AutoTest\\pages\\common_page.py\", line 216, in assert_prompt_information\n    ExceptionHandle().handle_exception(e, \"assert\")\n  File \"E:\\Wondersoft_AutoTest\\utils\\base_utils\\exception_handle.py\", line 58, in handle_exception\n    assert False\n"}, "attachments": [{"name": "测试用例校验失败：", "source": "07cf1407-a8b5-45dd-ac76-95c092dc79e6-attachment.attach"}], "parameters": [{"name": "message", "value": "'参数配置正确'"}, {"name": "locator", "value": "'[role=alert]'"}], "start": 1719192999322, "stop": 1719193004453}], "start": 1719192992177, "stop": 1719193004461, "uuid": "5afeb431-a112-468d-9d51-21ada8f2a368", "historyId": "8c0e9e8f0d70dbf5b4a3c941d916515d", "testCaseId": "07319840da96b436bf475fc318ed7a7a", "fullName": "test_cases.step_defs.bms.test_01_user_sync#test_配置数据源", "labels": [{"name": "feature", "value": "用户同步模块"}, {"name": "tag", "value": "@pytest.mark.usefixtures"}, {"name": "parentSuite", "value": "test_cases.step_defs.bms"}, {"name": "suite", "value": "test_01_user_sync"}, {"name": "host", "value": "DESKTOP-ATHT3TO"}, {"name": "thread", "value": "11544-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test_cases.step_defs.bms.test_01_user_sync"}]}